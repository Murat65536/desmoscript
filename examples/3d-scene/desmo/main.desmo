import "../../../desmo-lib/3d.desmo" as t;
import "../../../desmo-lib/binary.desmo" as bin;

multiObjToDesmoscript!(test, "assets/twomonkeys.obj")

currentFrame = 0;

ticker @{
  handlerLatex: ds(
    & 
    match { (mod(currentFrame, 30) == 0) => controls.updateMeshLookup; },
    currentFrame -> currentFrame + 1
  ),
  playing: true,
  open: true
}

ns controls {
  xpos = 0;
  ypos = 0;
  zpos = -3;

  xposMeshLookup = 0;
  yposMeshLookup = 0;
  zposMeshLookup = -5;

  updateMeshLookup = &
    xposMeshLookup -> xpos,
    yposMeshLookup -> ypos,
    zposMeshLookup -> zpos;
}


lookupMesh!(
  testLookup, test,
  -4 + controls.xposMeshLookup, -4 + controls.yposMeshLookup, -4 + controls.zposMeshLookup,
  4 + controls.xposMeshLookup, 4 + controls.yposMeshLookup, 4 + controls.zposMeshLookup,
  2
)

ns display {
  ns translated {
    x = testLookup.vertexPosition.x - controls.xpos;
    y = testLookup.vertexPosition.y - controls.ypos;
    z = testLookup.vertexPosition.z - controls.zpos;
  }

  ns average {
    x = 
      (
        testLookup.vertexPosition.x[testLookup.index.tri1]
        + testLookup.vertexPosition.x[testLookup.index.tri2]
        + testLookup.vertexPosition.x[testLookup.index.tri3]
      ) / 3;
    y = 
      (
        testLookup.vertexPosition.y[testLookup.index.tri1]
        + testLookup.vertexPosition.y[testLookup.index.tri2]
        + testLookup.vertexPosition.y[testLookup.index.tri3]
      ) / 3;
    z = 
      (
        testLookup.vertexPosition.z[testLookup.index.tri1]
        + testLookup.vertexPosition.z[testLookup.index.tri2]
        + testLookup.vertexPosition.z[testLookup.index.tri3]
      ) / 3;
  }

  ns viewAverage {
    x = average.x - controls.xpos;
    y = average.y - controls.ypos;
    z = average.z - controls.zpos;
  }

  polygonDepths = (
    (average.x - controls.xpos) ^ 2 + (average.y - controls.ypos) ^ 2 + (average.z - controls.zpos) ^ 2
  ) ^ 0.5;

  ns normalizedViewAverage {
    x = viewAverage.x / polygonDepths;
    y = viewAverage.y / polygonDepths;
    z = viewAverage.z / polygonDepths;
  }

  depthSortOrder = sort(1 .. length(testLookup.index.tri1), -1 * polygonDepths);

  ns light {
    x = 0;
    y = 0;
    z = 0;
  
    ns offset {
      x = light.x - average.x;
      y = light.y - average.y;
      z = light.z - average.z;

      mag = (x*x + y*y + z*z) ^ 0.5;
    }

    diffuse = 
      (offset.x / offset.mag * testLookup.normal.x
    + offset.y / offset.mag * testLookup.normal.y
    + offset.z / offset.mag * testLookup.normal.z) * 1;

    
    ns offset2 {
      x = -1 * light.x - average.x;
      y = -1 * light.y - average.y;
      z = 1 * light.z - average.z;

      mag = (x*x + y*y + z*z) ^ 0.5;
    }


    ns reflect {
      ndotl = 
      (offset2.x / offset2.mag * testLookup.normal.x
    + offset2.y / offset2.mag * testLookup.normal.y
    + offset2.z / offset2.mag * testLookup.normal.z) * 1;
      x = 2 * ndotl * testLookup.normal.x - offset2.x / offset2.mag * 1;
      y = 2 * ndotl * testLookup.normal.y - offset2.y / offset2.mag * 1;
      z = 2 * ndotl * testLookup.normal.z - offset2.z / offset2.mag * 1;
    }

    specular = 
        (max(t.dotns!(reflect, normalizedViewAverage), 0)) ^ 4;

  }

  // test = t.dotns!(a, b);

  colors = rgb(
    max(light.diffuse, 0) * 256 + light.specular * 256, 
    light.specular * 256, 
    light.specular * 256
  );  

  show polys = [
  getClippedPolygon(
    0.01,
    translated.x[testLookup.index.tri1[i]],
    translated.y[testLookup.index.tri1[i]],
    translated.z[testLookup.index.tri1[i]],
    translated.x[testLookup.index.tri2[i]],
    translated.y[testLookup.index.tri2[i]],
    translated.z[testLookup.index.tri2[i]],
    translated.x[testLookup.index.tri3[i]],
    translated.y[testLookup.index.tri3[i]],
    translated.z[testLookup.index.tri3[i]]
    )
  for
  i=1 .. length(testLookup.index.tri1)
  ][depthSortOrder]; with @{
    color: "red",
    lines: false,
    fillOpacity: ds(1),
    colorLatex: ds(
        colors[depthSortOrder]
    )
  }
}

















fn getClippedPolygon(
    near,
    x1, y1, z1,
    x2, y2, z2,
    x3, y3, z3
) {
    sortedDepths = sort([z1, z2, z3]);
    nonClippedCount = length(sortedDepths[sortedDepths > near]);
    match {
        (nonClippedCount == 3) => {polygon(
            (x1 / z1, y1 / z1),
            (x2 / z2, y2 / z2),
            (x3 / z3, y3 / z3)
        )};
        (nonClippedCount == 2) => {
            sortedXs = sort([x1, x2, x3], [z1, z2, z3]);
            sortedYs = sort([y1, y2, y3], [z1, z2, z3]);
            t1 = (near - sortedDepths[1]) / (sortedDepths[2] - sortedDepths[1]);
            t2 = (near - sortedDepths[1]) / (sortedDepths[3] - sortedDepths[1]);

            polygon(
                (sortedXs[2] / sortedDepths[2], sortedYs[2] / sortedDepths[2]),
                (sortedXs[3] / sortedDepths[3], sortedYs[3] / sortedDepths[3]),

                (
                    ((sortedXs[1] + t2 * (sortedXs[3] - sortedXs[1])) / near), 
                    ((sortedYs[1] + t2 * (sortedYs[3] - sortedYs[1])) / near)
                ),
                (
                    ((sortedXs[1] + t1 * (sortedXs[2] - sortedXs[1])) / near), 
                    ((sortedYs[1] + t1 * (sortedYs[2] - sortedYs[1])) / near)
                )
            )
        };
        (nonClippedCount == 1) => {
            sortedXs = sort([x1, x2, x3], [z1, z2, z3]);
            sortedYs = sort([y1, y2, y3], [z1, z2, z3]);
            t1 = (near - sortedDepths[3]) / (sortedDepths[1] - sortedDepths[3]);
            t2 = (near - sortedDepths[3]) / (sortedDepths[2] - sortedDepths[3]);

            polygon(
                (sortedXs[3] / sortedDepths[3], sortedYs[3] / sortedDepths[3]),

                (
                    ((sortedXs[3] + t2 * (sortedXs[2] - sortedXs[3])) / near), 
                    ((sortedYs[3] + t2 * (sortedYs[2] - sortedYs[3])) / near)
                ),
                (
                    ((sortedXs[3] + t1 * (sortedXs[1] - sortedXs[3])) / near), 
                    ((sortedYs[3] + t1 * (sortedYs[1] - sortedYs[3])) / near)
                )
            )
        };
        polygon((0/0,0/0));
    }
}