import "../../../desmo-lib/3d.desmo" as t;
import "../../../desmo-lib/binary.desmo" as bin;

multiObjToDesmoscript!(test, "assets/labyrinth_of_bernard.obj")

currentFrame = 0;

ticker @{ 
  handlerLatex: ds( 
    & 
    match { (mod(currentFrame, 30) == 0) => controls.updateMeshLookup; },
    currentFrame -> currentFrame + 1
  ),
  playing: true,
  open: true
}

ns controls {
  t.vec3!(pos, 1, 1, 1)
  t.vec3!(lookupPos, 0, 0, 0) 

  updateMeshLookup = &
    lookupPos.x -> pos.x,
    lookupPos.y -> pos.y,
    lookupPos.z -> pos.z;

  show rotationView = (0, 0); with @{}
 
  rotation = 10 * rotationView;
}
 

lookupMesh!( 
  testLookup, test,
  -4 + controls.lookupPos.x, -4 + controls.lookupPos.y, -4 + controls.lookupPos.z,
  4 + controls.lookupPos.x, 4 + controls.lookupPos.y, 4 + controls.lookupPos.z,
  12
)

ns display {
  // calculate view space
  deswizzle!(translated, testLookup.vertexPosition.xyz - controls.pos.xyz)
  ns rotated1 {
    x = translated.x * cos(controls.rotation\x) - translated.z * sin(controls.rotation\x);
    y = translated.y;
    z = translated.x * sin(controls.rotation\x) + translated.z * cos(controls.rotation\x);
  }
  ns view {
    x = rotated1.x;
    y = rotated1.y * cos(controls.rotation\y) - rotated1.z * sin(controls.rotation\y);
    z = rotated1.y * sin(controls.rotation\y) + rotated1.z * cos(controls.rotation\y);
  }

  // get average positions in world and view space
  deswizzle!(average, (
    testLookup.vertexPosition.xyz[testLookup.index.tri1]
    + testLookup.vertexPosition.xyz[testLookup.index.tri2]
    + testLookup.vertexPosition.xyz[testLookup.index.tri3]
  ) / 3)
  deswizzle!(viewAverage, average.xyz - controls.pos.xyz)
  t.normalize!(normalizedViewAverage, viewAverage)

  // depth sorting
  polygonDepths = normalizedViewAverage.mag;
  depthSortOrder = sort(1 .. length(testLookup.index.tri1), -1 * polygonDepths);
  polygonFilter = depthSortOrder[
    t.dotns!(normalizedViewAverage, testLookup.normal)[depthSortOrder] < 0
  ];

  ns light {
    show x = 0; with @{}
    show y = 0; with @{}
    show z = 0; with @{}
  
    // calculate diffuse light
    deswizzle!(offset, light.xyz - average.xyz)
    t.normalize!(normalizedOffset, offset)
    diffuse = t.dotns!(normalizedOffset, testLookup.normal);

    // calculate specular light
    ndotl = diffuse;
    deswizzle!(reflect, 2 * ndotl * testLookup.normal.xyz - normalizedOffset.xyz)
    deswizzle!(viewerVector, controls.pos.xyz - average.xyz)
    t.normalize!(normalizedViewerVector, viewerVector)
    reflectMag = (reflect.x^2 + reflect.y^2 + reflect.z^2)^0.5;
    specular = 
      match {
        (diffuse > 0) => 
          (max(t.dotns!(reflect, normalizedViewerVector), 0)) ^ 6;
        0;
      };

  }

  fn mix(a, b, factor) {
    clampedFactor = min(max(factor, 0), 1);
    b * clampedFactor + a * (1 - clampedFactor)
  }

  fogDistance = 55555;

  // calculate polygon colors
  ns polygonColorChannels {
    r = floor(max(light.diffuse, 0) * 4) / 4 * test.materials.diffuse.r[testLookup.materialIndices] * 256
     + light.specular * test.materials.specular.r[testLookup.materialIndices] * 256;
    g = floor(max(light.diffuse, 0) * 4) / 4 * test.materials.diffuse.g[testLookup.materialIndices] * 256
     + light.specular * test.materials.specular.g[testLookup.materialIndices] * 256;
    b = floor(max(light.diffuse, 0) * 4) / 4 * test.materials.diffuse.b[testLookup.materialIndices] * 256
     + light.specular * test.materials.specular.b[testLookup.materialIndices] * 256;
  }

  fogFactor = (polygonDepths / fogDistance * 4) / 4;

  colors = rgb(
    mix(polygonColorChannels.r, 0, fogFactor),
    mix(polygonColorChannels.g, 0, fogFactor),
    mix(polygonColorChannels.b, 0, fogFactor)    
  );  

  // display polygons
  show polys = [
  getClippedPolygon(
    0.01,
    view.x[testLookup.index.tri1[i]],
    view.y[testLookup.index.tri1[i]],
    view.z[testLookup.index.tri1[i]],
    view.x[testLookup.index.tri2[i]],
    view.y[testLookup.index.tri2[i]],
    view.z[testLookup.index.tri2[i]],
    view.x[testLookup.index.tri3[i]],
    view.y[testLookup.index.tri3[i]],
    view.z[testLookup.index.tri3[i]]
    )
  for
  i=1 .. length(testLookup.index.tri1)
  ][polygonFilter]; with @{
    color: "red",
    lines: false,
    fillOpacity: ds(1),
    colorLatex: ds(
        colors[polygonFilter]
    )
  }
}

















fn getClippedPolygon(
    near,
    x1, y1, z1,
    x2, y2, z2,
    x3, y3, z3
) {
    sortedDepths = sort([z1, z2, z3]);
    nonClippedCount = length(sortedDepths[sortedDepths > near]);
    screenSpace1 = (x1 / z1, y1 / z1);
    screenSpace2 = (x2 / z2, y2 / z2);
    screenSpace3 = (x3 / z3, y3 / z3);
    
    screenSpaceAvg = (screenSpace1 + screenSpace2 + screenSpace3) / 3;

    match {
        (nonClippedCount == 3) => {polygon(
            (screenSpace1 - screenSpaceAvg) * 1.03 + screenSpaceAvg,
            (screenSpace2 - screenSpaceAvg) * 1.03 + screenSpaceAvg,
            (screenSpace3 - screenSpaceAvg) * 1.03 + screenSpaceAvg
        )};
        (nonClippedCount == 2) => {
            sortedXs = sort([x1, x2, x3], [z1, z2, z3]);
            sortedYs = sort([y1, y2, y3], [z1, z2, z3]);
            t1 = (near - sortedDepths[1]) / (sortedDepths[2] - sortedDepths[1]);
            t2 = (near - sortedDepths[1]) / (sortedDepths[3] - sortedDepths[1]);

            polygon(
                (sortedXs[2] / sortedDepths[2], sortedYs[2] / sortedDepths[2]),
                (sortedXs[3] / sortedDepths[3], sortedYs[3] / sortedDepths[3]),

                (
                    ((sortedXs[1] + t2 * (sortedXs[3] - sortedXs[1])) / near), 
                    ((sortedYs[1] + t2 * (sortedYs[3] - sortedYs[1])) / near)
                ),
                (
                    ((sortedXs[1] + t1 * (sortedXs[2] - sortedXs[1])) / near), 
                    ((sortedYs[1] + t1 * (sortedYs[2] - sortedYs[1])) / near)
                )
            )
        };
        (nonClippedCount == 1) => {
            sortedXs = sort([x1, x2, x3], [z1, z2, z3]);
            sortedYs = sort([y1, y2, y3], [z1, z2, z3]);
            t1 = (near - sortedDepths[3]) / (sortedDepths[1] - sortedDepths[3]);
            t2 = (near - sortedDepths[3]) / (sortedDepths[2] - sortedDepths[3]);

            polygon(
                (sortedXs[3] / sortedDepths[3], sortedYs[3] / sortedDepths[3]),

                (
                    ((sortedXs[3] + t2 * (sortedXs[2] - sortedXs[3])) / near), 
                    ((sortedYs[3] + t2 * (sortedYs[2] - sortedYs[3])) / near)
                ),
                (
                    ((sortedXs[3] + t1 * (sortedXs[1] - sortedXs[3])) / near), 
                    ((sortedYs[3] + t1 * (sortedYs[1] - sortedYs[3])) / near)
                )
            )
        };
        polygon((0/0,0/0));
    }
}