import "../../../desmo-lib/3d.desmo" as t;
import "../../../desmo-lib/binary.desmo" as bin;
multiObjCelShadingToDesmoscript!(test, "assets/cubesagain2.obj")

currentFrame = 0;

ticker @{ 
  handlerLatex: ds( 
    & 
    match { (mod(currentFrame, 30) == 0) => controls.updateMeshLookup; },
    currentFrame -> currentFrame + 1
  ),
  playing: true,
  open: true
}

ns controls {
  t.vec3!(pos, 1, 1, 1)
  t.vec3!(lookupPos, 0, 0, 0) 

  updateMeshLookup = &
    lookupPos.x -> pos.x,
    lookupPos.y -> pos.y,
    lookupPos.z -> pos.z;

  show rotationView = (0, 0); with @{}
 
  rotation = 10 * rotationView;
}

sdfsdfsdf = 123123;

lookupCelShadingMesh!( 
  testLookup, test,
  -4 + controls.lookupPos.x, -4 + controls.lookupPos.y, -4 + controls.lookupPos.z,
  4 + controls.lookupPos.x, 4 + controls.lookupPos.y, 4 + controls.lookupPos.z,
  3
)

ns display {
  // calculate view space
  deswizzle!(translated, testLookup.vertexPosition.xyz - controls.pos.xyz)
  ns rotated1 {
    x = translated.x * cos(controls.rotation\x) - translated.z * sin(controls.rotation\x);
    y = translated.y;
    z = translated.x * sin(controls.rotation\x) + translated.z * cos(controls.rotation\x);
  }
  ns view {  
    x = rotated1.x;     
    y = rotated1.y * cos(controls.rotation\y) - rotated1.z * sin(controls.rotation\y);  
    z = rotated1.y * sin(controls.rotation\y) + rotated1.z * cos(controls.rotation\y);
  }
    
  // get average positions in world and view space
  deswizzle!(average, (   
    testLookup.vertexPosition.xyz[testLookup.index.tri1] 
    + testLookup.vertexPosition.xyz[testLookup.index.tri2]
    + testLookup.vertexPosition.xyz[testLookup.index.tri3]
  ) / 3)
  deswizzle!(viewAverage, average.xyz - controls.pos.xyz)
  t.normalize!(normalizedViewAverage, viewAverage)

  // depth sorting
  polygonDepths = normalizedViewAverage.mag;
  depthSortOrder = sort(1 .. length(testLookup.index.tri1), -1 * polygonDepths);
  polygonFilter = depthSortOrder;


  fn mix(a, b, factor) {
    clampedFactor = min(max(factor, 0), 1);
    b * clampedFactor + a * (1 - clampedFactor)
  }


  colors = rgb(
    test.r[testLookup.baseColor] + test.r[testLookup.light1Color] + test.r[testLookup.light2Color],
    test.g[testLookup.baseColor] + test.g[testLookup.light1Color] + test.g[testLookup.light2Color],
    test.b[testLookup.baseColor] + test.b[testLookup.light1Color] + test.b[testLookup.light2Color]
  );  

  colors2 = colors;

  // display polygons
  show polys = [
  getClippedPolygon(
    0.01,
    view.x[testLookup.index.tri1[i]],
    view.y[testLookup.index.tri1[i]],
    view.z[testLookup.index.tri1[i]],
    view.x[testLookup.index.tri2[i]],
    view.y[testLookup.index.tri2[i]],
    view.z[testLookup.index.tri2[i]],
    view.x[testLookup.index.tri3[i]],
    view.y[testLookup.index.tri3[i]],
    view.z[testLookup.index.tri3[i]]
    )
  for
  i=1 .. length(testLookup.index.tri1)
  ][polygonFilter]; with @{
    color: "red",
    lines: false,
    fillOpacity: ds(1),
    colorLatex: ds(
        colors[polygonFilter]
    )
  }
}
















fn pointMag(p) { (p\x * p\x + p\y * p\y) ^ 0.5 }

sub!(dist, nsname, xv, yv, zv, 
  ((nsname.x-xv)^2+(nsname.x-yv)^2+(nsname.x-zv)^2)^0.5
)
sub!(mag, nsname, 
  ((nsname.x)^2+nsname.y^2 +nsname.z^2)^0.5
)

polygonShift = 0.01;

fn getClippedPolygon(
    near,
    x1, y1, z1,
    x2, y2, z2,
    x3, y3, z3
) {
    sortedDepths = sort([z1, z2, z3]);
    nonClippedCount = length(sortedDepths[sortedDepths > near]);

    ns center {
      x = (x1 + x2 + x3) / 3;
      y = (y1 + y2 + y3) / 3;
      z = (z1 + z2 + z3) / 3;
    }

    ns offset1 {
      x = x1 - center.x;
      y = y1 - center.y;
      z = z1 - center.z;
    }
    offset1mag = mag!(offset1);
    ns offset2 {
      x = x2 - center.x;
      y = y2 - center.y;
      z = z2 - center.z;
    }
    offset2mag = mag!(offset2);
    ns offset3 {
      x = x3 - center.x;
      y = y3 - center.y;
      z = z3 - center.z;
    }
    offset3mag = mag!(offset3);

    deswizzle!(shifted1, offset1.xyz * (1 + center.z * polygonShift / offset1mag) + center.xyz)
    deswizzle!(shifted2, offset2.xyz * (1 + center.z * polygonShift / offset2mag) + center.xyz)
    deswizzle!(shifted3, offset3.xyz * (1 + center.z * polygonShift / offset3mag) + center.xyz)

    screenSpace1 = (shifted1.x / shifted1.z, shifted1.y / shifted1.z);
    screenSpace2 = (shifted2.x / shifted2.z, shifted2.y / shifted2.z);
    screenSpace3 = (shifted3.x / shifted3.z, shifted3.y / shifted3.z);

    match {
        (nonClippedCount == 3) => {polygon(
            screenSpace1, screenSpace2, screenSpace3
        )};
        (nonClippedCount == 2) => {
            sortedXs = sort([x1, x2, x3], [z1, z2, z3]);
            sortedYs = sort([y1, y2, y3], [z1, z2, z3]);
            t1 = (near - sortedDepths[1]) / (sortedDepths[2] - sortedDepths[1]);
            t2 = (near - sortedDepths[1]) / (sortedDepths[3] - sortedDepths[1]);

            polygon(
                (sortedXs[2] / sortedDepths[2], sortedYs[2] / sortedDepths[2]),
                (sortedXs[3] / sortedDepths[3], sortedYs[3] / sortedDepths[3]),

                (
                    ((sortedXs[1] + t2 * (sortedXs[3] - sortedXs[1])) / near), 
                    ((sortedYs[1] + t2 * (sortedYs[3] - sortedYs[1])) / near)
                ),
                (
                    ((sortedXs[1] + t1 * (sortedXs[2] - sortedXs[1])) / near), 
                    ((sortedYs[1] + t1 * (sortedYs[2] - sortedYs[1])) / near)
                )
            )
        };
        (nonClippedCount == 1) => {
            sortedXs = sort([x1, x2, x3], [z1, z2, z3]);
            sortedYs = sort([y1, y2, y3], [z1, z2, z3]);
            t1 = (near - sortedDepths[3]) / (sortedDepths[1] - sortedDepths[3]);
            t2 = (near - sortedDepths[3]) / (sortedDepths[2] - sortedDepths[3]);

            polygon(
                (sortedXs[3] / sortedDepths[3], sortedYs[3] / sortedDepths[3]),

                (
                    ((sortedXs[3] + t2 * (sortedXs[2] - sortedXs[3])) / near), 
                    ((sortedYs[3] + t2 * (sortedYs[2] - sortedYs[3])) / near)
                ),
                (
                    ((sortedXs[3] + t1 * (sortedXs[1] - sortedXs[3])) / near), 
                    ((sortedYs[3] + t1 * (sortedYs[1] - sortedYs[3])) / near)
                )
            )
        };
        polygon((0/0,0/0));
    }
}