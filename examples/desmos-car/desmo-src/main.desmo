import "../../../desmo-lib/3d.desmo" as t;

sub!(mulMat3,
    outVector,
    matrix, vector,
    ns outVector {
        x = matrix.x.x * vector.x + matrix.y.x * vector.y + matrix.z.x * vector.z;
        y = matrix.x.y * vector.x + matrix.y.y * vector.y + matrix.z.y * vector.z;
        z = matrix.x.z * vector.x + matrix.y.z * vector.y + matrix.z.z * vector.z;
    }
)

sub!(transform,
    outVector,
    vector,
    translation,
    matrix,
    ns outVector {
        x = matrix.x.x * vector.x + matrix.y.x * vector.y + matrix.z.x * vector.z + translation.x;
        y = matrix.x.y * vector.x + matrix.y.y * vector.y + matrix.z.y * vector.z + translation.y;
        z = matrix.x.z * vector.x + matrix.y.z * vector.y + matrix.z.z * vector.z + translation.z;
    }
)

sub!(transform2,
    outVector,
    vector,
    translation,
    matrix,
    ns outVector {
        xt = vector.x + translation.x;
        yt = vector.y + translation.y;
        zt = vector.z + translation.z;
        x = matrix.x.x * xt + matrix.y.x * yt + matrix.z.x * zt;
        y = matrix.x.y * xt + matrix.y.y * yt + matrix.z.y * zt;
        z = matrix.x.z * xt + matrix.y.z * yt + matrix.z.z * zt;
    }
)

sub!(vec3,
    name,
    xvalues, yvalues, zvalues,
    ns name { x=xvalues; y=yvalues; z=zvalues; }
)

sub!(mat3,
    name,
    xx, xy, xz,
    yx, yy, yz,
    zx, zy, zz,
    ns name {
        ns x { x=xx; y=xy; z=xz; }
        ns y { x=yx; y=yy; z=yz; }
        ns z { x=zx; y=zy; z=zz; }
    }
)

sub!(mat3identity,
    name,
    mat3!(
        name,
        1, 0, 0,
        0, 1, 0,
        0, 0, 1
    ))

sub!(mat3FirstPerson,
    name,
    c,
    ns name {
        xx = cos(c\x); // x's contribution to x
        xz = -1 * sin(c\x); // x's contribution to z
        zx = sin(c\x);
        zz = cos(c\x);
        ns x { x=xx; y=0; z=zx; }
        ns y { x=-1*xz*sin(c\y); y=cos(c\y); z=-1*zz*sin(c\y); }
        ns z { x=xz*cos(c\y); y=sin(c\y); z=zz*cos(c\y); }
    }
)

sub!(cross,
    outvec,
    v1, v2,
    vec3!(
        outvec,
        v1.y * v2.z - v1.z * v2.y,
        v1.z * v2.x - v1.x * v2.z,
        v1.x * v2.y - v1.y * v2.x
    )
)


sub!(rodrigues,
    outvec,
    v, angle, axis,
    ns outvec {
        cosAngle = cos(angle);
        sinAngle = sin(angle);
        cross!(crossKV, v, axis)
        dotKV = v.x * axis.x + v.y * axis.y + v.z * axis.z;
        x = v.x * cosAngle + crossKV.x * sinAngle + axis.x * dotKV * (1 - cosAngle);
        y = v.y * cosAngle + crossKV.y * sinAngle + axis.y * dotKV * (1 - cosAngle);
        z = v.z * cosAngle + crossKV.z * sinAngle + axis.z * dotKV * (1 - cosAngle);
    }
)

sub!(rotateMat3,
    outmat,
    matrix, angle, axis,
    ns outmat {
        rodrigues!(x, matrix.x, angle, axis)
        rodrigues!(y, matrix.y, angle, axis)
        rodrigues!(z, matrix.z, angle, axis)
    }
)

sub!(rodriguesAction,
    actionName,
    v, angle, axis,
    ns actionName {
        cosAngle = cos(angle);
        sinAngle = sin(angle);
        cross!(crossKV, v, axis)
        dotKV = v.x * axis.x + v.y * axis.y + v.z * axis.z;
        action = & v.x -> v.x * cosAngle + crossKV.x * sinAngle + axis.x * dotKV * (1 - cosAngle),
                   v.y -> v.y * cosAngle + crossKV.y * sinAngle + axis.y * dotKV * (1 - cosAngle),
                   v.z -> v.z * cosAngle + crossKV.z * sinAngle + axis.z * dotKV * (1 - cosAngle);
    }
)

sub!(rotateMat3Action,
    actionName,
    matrix, angle, axis,
    ns actionName {
        rodriguesAction!(x, matrix.x, angle, axis)
        rodriguesAction!(y, matrix.y, angle, axis)
        rodriguesAction!(z, matrix.z, angle, axis)
        action = & x.action, y.action, z.action;
    }
)

sub!(normalize,
    outvec, v,
    ns outvec {
        mag = (v.x * v.x + v.y * v.y + v.z * v.z) ^ 0.5;
        x = v.x / mag;
        y = v.y / mag;
        z = v.z / mag;
    }
)

mat3identity!(identityMatrix)



fn getClippedPolygon(
    near,
    x1, y1, z1,
    x2, y2, z2,
    x3, y3, z3
) {
    sortedDepths = sort([z1, z2, z3]);
    nonClippedCount = length(sortedDepths[sortedDepths > near]);
    match {
        (nonClippedCount == 3) => {polygon(
            (x1 / z1, y1 / z1),
            (x2 / z2, y2 / z2),
            (x3 / z3, y3 / z3)
        )};
        (nonClippedCount == 2) => {
            sortedXs = sort([x1, x2, x3], [z1, z2, z3]);
            sortedYs = sort([y1, y2, y3], [z1, z2, z3]);
            t1 = (near - sortedDepths[1]) / (sortedDepths[2] - sortedDepths[1]);
            t2 = (near - sortedDepths[1]) / (sortedDepths[3] - sortedDepths[1]);

            polygon(
                (sortedXs[2] / sortedDepths[2], sortedYs[2] / sortedDepths[2]),
                (sortedXs[3] / sortedDepths[3], sortedYs[3] / sortedDepths[3]),

                (
                    (t2 * (sortedXs[1] + (sortedXs[3] - sortedXs[1])) / near), 
                    (t2 * (sortedYs[1] + (sortedYs[3] - sortedYs[1])) / near)
                ),
                (
                    (t1 * (sortedXs[1] + (sortedXs[2] - sortedXs[1])) / near), 
                    (t1 * (sortedYs[1] + (sortedYs[2] - sortedYs[1])) / near)
                )
            )
        };
        (nonClippedCount == 1) => {
            sortedXs = sort([x1, x2, x3], [z1, z2, z3]);
            sortedYs = sort([y1, y2, y3], [z1, z2, z3]);
            t1 = (near - sortedDepths[3]) / (sortedDepths[1] - sortedDepths[3]);
            t2 = (near - sortedDepths[3]) / (sortedDepths[2] - sortedDepths[3]);

            polygon(
                (sortedXs[3] / sortedDepths[3], sortedYs[3] / sortedDepths[3]),

                (
                    (t2 * (sortedXs[3] + (sortedXs[2] - sortedXs[3])) / near), 
                    (t2 * (sortedYs[3] + (sortedYs[2] - sortedYs[3])) / near)
                ),
                (
                    (t1 * (sortedXs[3] + (sortedXs[1] - sortedXs[3])) / near), 
                    (t1 * (sortedYs[3] + (sortedYs[1] - sortedYs[3])) / near)
                )
            )
        };
        polygon((0/0,0/0));
    }
}

ns view {
    rotationView = (0, 0);


    xRotation = 0; //rotationController\x / 3.14159265;

    rotationController = (xRotation, 10 * rotationView\y);

    mat3FirstPerson!(matrix, rotationController)


    xzSliderView = (0, 0);
    xzSliderController = 30 * xzSliderView;

    ySliderController = 0;
    ySliderView = (0, 0.01 * ySliderController);

    vec3!(pos, xzSliderController\x, ySliderController, xzSliderController\y)
}

ns ground {
    loadObj!(mesh, "../assets/ground.obj")
    transform2!(viewSpace, mesh.vertices, view.pos, view.matrix)

    ns i {
        t1 = mesh.vertexIndices[1, 4 .. length(mesh.vertexIndices)];
        t2 = mesh.vertexIndices[2, 5 .. length(mesh.vertexIndices)];
        t3 = mesh.vertexIndices[3, 6 .. length(mesh.vertexIndices)];
    }

    show 
        polygons = [getClippedPolygon(0.001,
            viewSpace.x[i.t1[index]],
            viewSpace.y[i.t1[index]],
            viewSpace.z[i.t1[index]],
            viewSpace.x[i.t2[index]],
            viewSpace.y[i.t2[index]],
            viewSpace.z[i.t2[index]],
            viewSpace.x[i.t3[index]],
            viewSpace.y[i.t3[index]],
            viewSpace.z[i.t3[index]]
        ) for index=1 .. length(i.t1)];
    with @{ color: "black"  }


}



makeBuiltin!(arctan)

cameraAngle = arctan(car.body.rotation.x.z, car.body.rotation.x.x) + 1.57079633;

updateCamera = &
    view.pos.x -> -1 * car.body.pos.x + 10 * cos(cameraAngle),
    view.pos.y -> -1 * car.body.pos.y - 3,
    view.pos.z -> -1 * car.body.pos.z + 10 * sin(cameraAngle),
    view.xRotation -> -1 * cameraAngle + 1.57079633
    ;

ns car {

    show carControllerView = (0, 0); with @{ color: "black" }
    show carController = 0.002 * carControllerView;

    loadObj!(mesh, "../assets/desmos-car-assets.obj")

    ns i {
        t1 = mesh.vertexIndices[1, 4 .. length(mesh.vertexIndices)];
        t2 = mesh.vertexIndices[2, 5 .. length(mesh.vertexIndices)];
        t3 = mesh.vertexIndices[3, 6 .. length(mesh.vertexIndices)];
    }

    ns body {
        momentOfInertia = 10;
        mass = 1;
        vec3!(pos, 0, 0, 10)

        // rotation matrix
        mat3identity!(rotation)

        vec3!(linearVel, 0, 0.001, 0)
        ns angularVel {
            x = 0.003;
            y = 0.003;
            z = 0.005;
        }
        normalize!(angularVelN, angularVel)

        rotateMat3Action!(rotateMatrix, rotation, angularVelN.mag, angularVelN)

        ns force {
            // inputs
            vec3!(offset, 1, 0, 0)
            vec3!(vector, 0, 0, 0)

            // result
            cross!(torque, offset, vector)
        }

        move = & 
            pos.x -> pos.x + linearVel.x, 
            pos.y -> pos.y + linearVel.y, 
            pos.z -> pos.z + linearVel.z;


        ns wheels {
            x = [-0.7, 0.7, -0.7, 0.7];
            y = [-1, -1, -1, -1];
            z = [-1, -1, 1, 1];
        }

        ns wheelOffsets {
            x = [-1.1, 1.1, -1.1, 1.1];
            y = [-1.1, -1.1, -1.1, -1.1];
            z = [-1.5, -1.5, 1.5, 1.5];
        }

        transform!(transformedWheelOffsets, wheelOffsets, car.body.pos, car.body.rotation)
        transform!(rotatedWheelOffsets, wheelOffsets, origin, car.body.rotation)

        vec3!(origin, 0, 0, 0)

        rti = [
            {
                allIntersects = t.rayTriangleIntersection(
                    transformedWheelOffsets.x[index],
                    transformedWheelOffsets.y[index],
                    transformedWheelOffsets.z[index],
                    0, -1, 0,
                    ground.mesh.vertices.x[ground.i.t1],
                    ground.mesh.vertices.y[ground.i.t1],
                    ground.mesh.vertices.z[ground.i.t1],
                    ground.mesh.vertices.x[ground.i.t2],
                    ground.mesh.vertices.y[ground.i.t2],
                    ground.mesh.vertices.z[ground.i.t2],
                    ground.mesh.vertices.x[ground.i.t3],
                    ground.mesh.vertices.y[ground.i.t3],
                    ground.mesh.vertices.z[ground.i.t3]
                );
                positiveIntersects = allIntersects[allIntersects > 0];
                positiveIntersectIndices = (1 .. length(allIntersects))[allIntersects > 0];
                minPositiveIntersect = min(positiveIntersects);
                (minPositiveIntersect, positiveIntersectIndices[positiveIntersects == minPositiveIntersect][1])
            }
            for
            index=[1,2,3,4]
        ];

        vec3!(wheelNormalForces, 
        match {
            (rti\x < 0.5) => ground.mesh.normals.x[rti\y] * 0.01;
            0;
        }, 
        match {
            (rti\x < 0.5) => ground.mesh.normals.y[rti\y] * 0.01;
            0;
        },
        match {
            (rti\x < 0.5) => ground.mesh.normals.z[rti\y] * 0.01;
            0;
        })

        cross!(torqueFromWheels, wheelNormalForces, rotatedWheelOffsets)

        accelerate = & 
            angularVel.x -> 0.99 * angularVel.x + total(torqueFromWheels.x) / momentOfInertia,
            angularVel.y -> 0.99 * angularVel.y + total(torqueFromWheels.y) / momentOfInertia
            - carController\x * 0.4,
            angularVel.z -> 0.99 * angularVel.z + total(torqueFromWheels.z) / momentOfInertia,
            linearVel.x -> 0.98 * linearVel.x + total(wheelNormalForces.x) / mass 
                + (0
                - carController\y / mass * sin(1 * cameraAngle + 1* 1.57079633)) * -5.0
                ,
            linearVel.y -> 0.98 * linearVel.y + total(wheelNormalForces.y) / mass - 0.002,
            linearVel.z -> 0.98 * linearVel.z + total(wheelNormalForces.z) / mass
                + (0
                + carController\y / mass * cos(1 * cameraAngle + 1*1.57079633)) * -5.0;
    }

    transform!(worldSpace, car.mesh.vertices, car.body.pos, car.body.rotation)

    transform2!(viewSpace, car.worldSpace, view.pos, view.matrix)
}


/*
persp = (
    car.viewSpace.x / car.viewSpace.z, 
    car.viewSpace.y / car.viewSpace.z
);*/

show 
    polygons = [getClippedPolygon(0.001,
        car.viewSpace.x[car.i.t1[index]],
        car.viewSpace.y[car.i.t1[index]],
        car.viewSpace.z[car.i.t1[index]],
        car.viewSpace.x[car.i.t2[index]],
        car.viewSpace.y[car.i.t2[index]],
        car.viewSpace.z[car.i.t2[index]],
        car.viewSpace.x[car.i.t3[index]],
        car.viewSpace.y[car.i.t3[index]],
        car.viewSpace.z[car.i.t3[index]]
    ) for index=1 .. length(car.i.t1)];
with @{ color: "black"  }

run = &  
    car.body.rotateMatrix.action,
    car.body.move,
    car.body.accelerate,
    updateCamera;

setOX = & car.body.force.offset.x -> 0;
setOY = & car.body.force.offset.y -> 0;
setOZ = & car.body.force.offset.z -> 0;
setVX = & car.body.force.vector.x -> 0;
setVY = & car.body.force.vector.y -> 0;
setVZ = & car.body.force.vector.z -> 0;

settings @{
    viewport: {
        xmin: -2,
        ymin: -2,
        xmax: 2,
        ymax: 2
    },
    showGrid: false,
    showXAxis: false,
    showYAxis: false
}

ticker @{
    handlerLatex: ds(run),
    open: true
}

